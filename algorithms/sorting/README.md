# 排序

## 排序算法与复杂度归类

* 几种最经典、最常用的排序算法：[冒泡排序](./bubble-sort/README.md)、[插入排序](./insertion-sort/README.md)、[选择排序](./selection-sort/README.md)、快速排序、归并排序、计数排序、基数排序、希尔排序、堆排序。
* 复杂度归类
  * 冒泡排序、插入排序、选择排序 O(n^2)
  * 快速排序、归并排序、堆排序 O(nlogn)
  * 计数排序、基数排序、桶排序 O(n)

## 如何分析一个“排序算法”？

* 算法的执行效率
  * 最好、最坏、平均情况时间复杂度。
  * 在对同一阶时间复杂度的排序算法性能对比的时候需要把系数、常数和低阶也考虑进来。
  * 基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。。
* 排序算法的稳定性
  * 稳定性概念：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。
  * 稳定性重要性：可针对对象的多种属性进行有优先级的排序。
  * 举例：给电商交易系统中的“订单”排序，按照金额大小对订单数据排序，对于相同金额的订单以下单时间早晚排序。用稳定排序算法可简洁地解决。先按照下单时间给订单排序，排序完成后用稳定排序算法按照订单金额重新排序。
  ![稳定性](../../resources/sorting/sort1.jpg)
* 排序算法的内存损耗
  
  原地排序算法：特指空间复杂度是O(1)的排序算法。


| 名称                  | 最优      | 平均      | 最坏          | 内存      | 稳定      | 备注                  |
| --------------------- | :-------: | :-------: | :-----------: | :-------: | :-------: | --------------------- |
| **冒泡排序**          | n         | n^2       | n^2           | 1         | Yes       |                       |
| **插入排序**          | n         | n^2       | n^2           | 1         | Yes       |                       |
| **选择排序**          | n^2       | n^2       | n^2           | 1         | No        |                       |
| **堆排序**            | n log(n)  | n log(n)  | n log(n)      | 1         | No        |                       |
| **归并排序**          | n log(n)  | n log(n)  | n log(n)      | n         | Yes       |                       |
| **快速排序**          | n log(n)  | n log(n)  | n^2           | log(n)    | No        | 在 in-place 版本下，内存复杂度通常是 O(log(n)) |
| **希尔排序**          | n log(n)  | 取决于差距序列   | n (log(n))^2  | 1         | No        |  |
| **计数排序**          | n + r     | n + r     | n + r         | n + r     | Yes       | r - 数组里最大的数    |
| **基数排序**          | n * k     | n * k     | n * k         | n + k     | Yes       | k - 最长 key 的升序   |

## 参考

- [数据结构与算法之美](https://time.geekbang.org/column/intro/126)
- [javascript-algorithms](https://github.com/trekhleb/javascript-algorithms)