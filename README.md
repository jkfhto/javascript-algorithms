# # JavaScript 算法与数据结构

## 数据结构

数据结构是在计算机中组织和存储数据的一种特殊方式，使得数据可以高效地被访问和修改。更确切地说，数据结构是数据值的集合，表示数据之间的关系，也包括了作用在数据上的函数或操作。

* [栈](stack/README.md)
* [队列](queue/README.md)
* [链表](linked-list/README.md)
* [字典](dictionay/README.md)
* [集合](set/README.md)
* [哈希表](hash-table/README.md)
* [树](tree/README.md)
  * [二叉搜索树](tree/binary-search-tree/README.md)
  * [红黑树](tree/red-black-tree/README.md)
* [图](graph/README.md)

## 算法

算法是如何解决一类问题的明确规范。算法是一组精确定义操作序列的规则。

`B` - 初学者， `A` - 进阶

### 算法主题

* **排序**
  * `B` [冒泡排序](./algorithms/sorting/bubble-sort)
  * `B` [选择排序](./algorithms/sorting/selection-sort)
  * `B` [插入排序](./algorithms/sorting/insertion-sort)
  * `B` [快速排序](./algorithms/sorting/quick-sort) - in-place (原地) 和 non-in-place 版本
  * `B` [希尔排序](./algorithms/sorting/shell-sort)

## 复杂度分析

* 什么是复杂度分析？
  * 1.数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。
  * 2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。
  * 3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。
  * 4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。
* 为什么要进行复杂度分析？
  * 1.和性能测试（事后统计法）相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。
  * 2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。
  * 3.不用具体的测试数据来测试，就可以粗略地估计算法的执行效率。
* 如何进行复杂度分析？
  * 大O表示法
    * 来源：算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。
    * 特点：以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。
  * 复杂度分析法则
    * 单段代码看高频：比如循环，只关注循环执行次数最多的一段代码
    * 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度，总的时间复杂度就等于量级最大的那段代码的时间复杂度
    * 嵌套代码求乘积：比如递归、多重循环等，嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
    * 多个规模求加法：比如方法有两个参数控制两个循环的次数，我们无法事先评估两个参数谁的量级大，所以我们在表示复杂度时就取二者复杂度相加。
* 常用的复杂度级别？
  * 多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）
  * 非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，O(2^n)（指数阶）、O(n!)（阶乘阶）
* 复杂度分析的4个概念
  * 最好情况时间复杂度：在最理想的情况下，执行这段代码的时间复杂度。
  * 最坏情况时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度。
  * 平均情况时间复杂度：加权平均时间复杂度（亦称为期望时间复杂度）。最好、最坏情况时间复杂度都是极端情况下的代码复杂度，发生的概率很小。因此，我们还需要知道平均情况时间复杂度。平均复杂度只在某些特殊情况下才用到。
  * 均摊时间复杂度：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度较高。而且这些操作之间存在前后连贯的时序关系，在这个时候，我们可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度较低的操作上。（在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度）均摊时间复杂度的应用场景比平均时间复杂度更加特殊、更加有限。

时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系

## 有用的信息

### 引用

[▶ YouTube上的数据结构和算法](https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)

### 大O符号

大O符号中指定的算法的增长顺序。

![Big O graphs](./resources/big-o-graph.png)

源: [Big O Cheat Sheet](http://bigocheatsheet.com/).

以下是一些最常用的 大O标记法 列表以及它们与不同大小输入数据的性能比较。

| 大O标记法      | 计算10个元素                 | 计算100个元素                 | 计算1000个元素                  |
| -------------- | ---------------------------- | ----------------------------- | ------------------------------- |
| **O(1)**       | 1                            | 1                             | 1                               |
| **O(log N)**   | 3                            | 6                             | 9                               |
| **O(N)**       | 10                           | 100                           | 1000                            |
| **O(N log N)** | 30                           | 600                           | 9000                            |
| **O(N^2)**     | 100                          | 10000                         | 1000000                         |
| **O(2^N)**     | 1024                         | 1.26e+29                      | 1.07e+301                       |
| **O(N!)**      | 3628800                      | 9.3e+157                      | 4.02e+2567                      |

### 数据结构操作的复杂性

| 数据结构       |  访问  |  查找  |  插入  |  删除  | 备注 |
| -------------- | :----: | :----: | :----: | :----: | ---- |
| **数组**       |   1    |   n    |   n    |   n    |      |
| **栈**         |   n    |   n    |   1    |   1    |      |
| **队列**       |   n    |   n    |   1    |   1    |      |
| **链表**       |   n    |   n    |   1    |   1    |      |
| **哈希表**     |   -    |   n    |   n    |   n    | 在完全哈希函数情况下，复杂度是 O(1） |
| **二分查找树** |   n    |   n    |   n    |   n    | 在平衡树情况下，复杂度是 O(log(n)) |
| **B 树**       | log(n) | log(n) | log(n) | log(n) |      |
| **红黑树**     | log(n) | log(n) | log(n) | log(n) |      |
| **AVL 树**     | log(n) | log(n) | log(n) | log(n) |      |
| **布隆过滤器** |   -    |   1    |   1    | - | 存在一定概率的判断错误（误判成存在） |

### 数组排序算法的复杂性

| 名称                  | 最优      | 平均      | 最坏          | 内存      | 稳定      | 备注                  |
| --------------------- | :-------: | :-------: | :-----------: | :-------: | :-------: | --------------------- |
| **冒泡排序**          | n         | n^2       | n^2           | 1         | Yes       |                       |
| **插入排序**          | n         | n^2       | n^2           | 1         | Yes       |                       |
| **选择排序**          | n^2       | n^2       | n^2           | 1         | No        |                       |
| **堆排序**            | n log(n)  | n log(n)  | n log(n)      | 1         | No        |                       |
| **归并排序**          | n log(n)  | n log(n)  | n log(n)      | n         | Yes       |                       |
| **快速排序**          | n log(n)  | n log(n)  | n^2           | log(n)    | No        | 在 in-place 版本下，内存复杂度通常是 O(log(n)) |
| **希尔排序**          | n log(n)  | 取决于差距序列   | n (log(n))^2  | 1         | No        |  |
| **计数排序**          | n + r     | n + r     | n + r         | n + r     | Yes       | r - 数组里最大的数    |
| **基数排序**          | n * k     | n * k     | n * k         | n + k     | Yes       | k - 最长 key 的升序   |

